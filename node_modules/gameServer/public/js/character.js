module.exports = character;

function character (THREE, type, username) {
    'use strict';

    this.username = username;
    var geometry = new THREE.BoxGeometry(10, 10, 10);

    var material = new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: false });
    //material = new THREE.MeshLambertMaterial({ color: 0xff0000});

    var body = new THREE.Mesh(geometry, material);

    this.mesh = new THREE.Object3D();
    this.mesh.add(body);
    this.direction = new THREE.Vector3(0, 0, 0);



    this.setDirection = function (controls) {
        'use strict';
        // Either left or right, and either up or down (no jump or dive (on the Y axis), so far ...)

        var x = controls.x,
            y = controls.y,
            z = controls.z ;
        this.direction.set(this.direction.x + x/10, this.direction.y + y/10,this.direction.z + z/10);
    };


    // Process the character motions
    this.motion= function () {
        'use strict';
        // Update the directions if we intersect with an obstacle
        this.collision();
        // If we're not static
        if (this.direction.x !== 0 || this.direction.z !== 0) {
            // Rotate the character
            this.rotate();
            // Move the character
            this.move();
            return true;
        }
    }
    // Test and avoid collisions
    this.collision =function () {

        return;
        'use strict';
        var collisions, i,
        // Maximum distance from the origin before we consider collision
            distance = 32,
        // Get the obstacles array from our world
            obstacles = basicScene.world.getObstacles();
        // For each ray
        for (i = 0; i < this.rays.length; i += 1) {
            // We reset the raycaster to this direction
            this.caster.set(this.mesh.position, this.rays[i]);
            // Test if we intersect with any obstacle mesh
            collisions = this.caster.intersectObjects(obstacles);
            // And disable that direction if we do
            if (collisions.length > 0 && collisions[0].distance <= distance) {
                // Yep, this.rays[i] gives us : 0 => up, 1 => up-left, 2 => left, ...
                if ((i === 0 || i === 1 || i === 7) && this.direction.z === 1) { this.direction.setZ(0); } else if ((i === 3 || i === 4 || i === 5) && this.direction.z === -1) { this.direction.setZ(0); }
                if ((i === 1 || i === 2 || i === 3) && this.direction.x === 1) { this.direction.setX(0); } else if ((i === 5 || i === 6 || i === 7) && this.direction.x === -1) { this.direction.setX(0); }
            }
        }
    }
    // Rotate the character
    this.rotate = function () {
        'use strict';
        // Set the direction's angle, and the difference between it and our Object3D's current rotation
        var angle = Math.atan2(this.direction.x, this.direction.z),
            difference = angle - this.mesh.rotation.y;
        // If we're doing more than a 180°
        if (Math.abs(difference) > Math.PI) {
            // We proceed to a direct 360° rotation in the opposite way
            if (difference > 0) { this.mesh.rotation.y += 2 * Math.PI; } else { this.mesh.rotation.y -= 2 * Math.PI; }
            // And we set a new smarter (because shorter) difference
            difference = angle - this.mesh.rotation.y;
            // In short : we make sure not to turn "left" to go "right"
        }
        // Now if we haven't reach our target angle
        if (difference !== 0) {
            // We slightly get closer to it
            this.mesh.rotation.y += difference / 4;
        }
    }

    this.move= function () {
        'use strict';
        // We update our Object3D's position from our "direction"
        this.mesh.position.x += this.direction.x * ((this.direction.z === 0) ? 4 : Math.sqrt(8));
        this.mesh.position.z += this.direction.z * ((this.direction.x === 0) ? 4 : Math.sqrt(8));


          //console.log("x" + this.mesh.position.x);
        //  console.log("z" + this.mesh.position.z);

    }


    this.getPosition = function(){
        return {"x":this.mesh.position.x, "y":this.mesh.position.y,"z":this.mesh.position.z}
    }
    this.getDirection= function(){
        return {"x":this.direction.x, "y":this.direction.y,"z":this.direction.z}
    }

    this.setPosition = function(x,y,z){
        this.mesh.position.x = x;
        this.mesh.position.y = y;
        this.mesh.position.z = z;
    }
    this.getCommsData = function(){
        return {"username":this.username, "position":this.getPosition(),"direction":this.getDirection()}

    }




}



